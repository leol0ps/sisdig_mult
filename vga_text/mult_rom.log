KCPSM6 Assembler log file for program 'C:\Users\aluno\Desktop\vga_text\KCPSM6_Release9_30Sept14.zip (Unzipped Files)\mult_rom.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 15 Feb 2023
Assembly timestamp: 15:39:10

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 093 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 148
Memory locations available: 3948


Assembly listing

 Addr Code                       Instruction

 000                             ;=========================================================
 000                             ; multiplication circuit with bcd input/output
 000                             ;=========================================================
 000                             ;Program operation:
 000                             ;  - read a and b from switch
 000                             ;  - calculate a*b
 000                             ;  - display data on vga
 000                             ;=========================================================
 000                             ; Data ram address alias
 000                             ;=========================================================
 000                             CONSTANT a_lsb, 00
 000                             CONSTANT b_lsb, 02
 000                             CONSTANT aa_lsb, 04
 000                             CONSTANT aa_msb, 05
 000                             CONSTANT bb_lsb, 06
 000                             CONSTANT bb_msb, 07
 000                             CONSTANT aabb_lsb, 08
 000                             CONSTANT aabb_msb, 09
 000                             CONSTANT aabb_cout, 0A
 000                             CONSTANT led0, 10
 000                             CONSTANT led1, 11
 000                             CONSTANT led2, 12
 000                             CONSTANT led3, 13
 000                             CONSTANT save, 14
 000                             CONSTANT p_bcd_result_lsb, 15
 000                             CONSTANT p_bcd_result_msb, 16
 000                             CONSTANT a_bin, 17
 000                             CONSTANT b_bin, 18
 000                             CONSTANT prod_lsb, 19
 000                             CONSTANT prod_msb, 20
 000                             ;=========================================================
 000                             ; Register alias
 000                             ;=========================================================
 000                             ;commonly used local variables
 000                             NAMEREG s0, data                     ;reg for temporary data
 000                             NAMEREG s1, addr                     ;reg for temporary mem & i/o port addr
 000                             NAMEREG s2, i                        ;general-purpose loop index
 000                             ;global variables
 000                             NAMEREG sF, switch_a_b               ;ram offset for current switch input
 000                             ;=========================================================
 000                             ; Port alias
 000                             ;=========================================================
 000                             ;------------input port definitions---------------------
 000                             CONSTANT rd_flag_port, 00            ;2 flags (xxxxxxsc):
 000                             CONSTANT sw_port, 01                 ;8-bit switch
 000                             CONSTANT mult_prod0_port, 02         ;multiplication product 8 LSBs
 000                             CONSTANT mult_prod1_port, 03         ;multiplication product 8 MSBs
 000                             ;------------output port definitions---------------------
 000                             CONSTANT result_lsb_port, 00         ;
 000                             CONSTANT result_msb_port, 01         ;
 000                             CONSTANT mult_src0_port, 02          ;multiplier operand 0
 000                             CONSTANT mult_src1_port, 03          ;multiplier operand 1
 000                             CONSTANT erro_port, 04               ; flag de erro
 000                             ;=========================================================
 000                             ; Main program
 000                             ;=========================================================
 000                             ;Calling hierarchy:
 000                             ;
 000                             ;main
 000                             ;  - init
 000                             ;  - proc_btn
 000                             ;      - init
 000                             ;  - convert_bcd_to_bin
 000                             ;  - multab
 000                             ;    - mult_hard
 000                             ;  - convert_bin_to_bcd
 000                             ;  - port output
 000                             ; =========================================================
 000  20007                      CALL 007[init]                       ;initialization
 001                    forever: 
 001                             ;main loop body
 001  2000E                      CALL 00E[proc_btn]                   ;check & process buttons
 002  20053                      CALL 053[convert_bcd_to_bin]         ;
 003  20021                      CALL 021[multab]                     ;calculate a*b
 004  20027                      CALL 027[convert_bin_to_bcd]
 005  2001C                      CALL 01C[final_bcd_result]           ; output produto bcd final
 006  22001                      JUMP 001[forever]
 007                             ;=========================================================
 007                             ;routine: init
 007                             ;  function: perform initialization, clear register/ram
 007                             ;  output register:
 007                             ;    switch_a_b: cleared to 0
 007                             ;  temp register: data, i
 007                             ;=========================================================
 007                       init: 
 007                             ;clear memory
 007  01240                      LOAD s2[i], 40                       ;unitize loop index to 64
 008  01000                      LOAD s0[data], 00
 009               clr_mem_loop: 
 009  2E020                      STORE s0[data], (s2[i])
 00A  19201                      SUB s2[i], 01                        ;dec loop index
 00B  36009                      JUMP NZ, 009[clr_mem_loop]           ;repeat until i=0
 00C                             ;clear register
 00C  01F00                      LOAD sF[switch_a_b], 00
 00D  25000                      RETURN 
 00E                             ;=========================================================
 00E                             ;routine: proc_btn
 00E                             ;  function: check two buttons and process the display
 00E                             ;  input reg:
 00E                             ;     switch_a_b: ram offset (0 for a and 2 for b)
 00E                             ;  output register:
 00E                             ;     s3: store input port flag
 00E                             ;     switch_a_b: may be toggled
 00E                             ;  temp register used: data, addr
 00E                             ;=========================================================
 00E                   proc_btn: 
 00E  09300                      INPUT s3, 00[rd_flag_port]           ;get flag
 00F                             ;check and process c button
 00F  0D301                      TEST s3, 01                          ;check c button flag
 010  32013                      JUMP Z, 013[chk_btns]                ;flag not set
 011  20007                      CALL 007[init]                       ;flag set, clear
 012  2201B                      JUMP 01B[proc_btn_done]
 013                   chk_btns: 
 013                             ;check and process s button
 013  0D302                      TEST s3, 02                          ;check s button flag
 014  3201B                      JUMP Z, 01B[proc_btn_done]           ;flag not set
 015  09001                      INPUT s0[data], 01[sw_port]          ;get switch
 016  2007F                      CALL 07F[check_bcd_valid]            ;check bcd
 017  01100                      LOAD s1[addr], 00[a_lsb]             ;get addr of a
 018  101F0                      ADD s1[addr], sF[switch_a_b]         ;add offset
 019  2E010                      STORE s0[data], (s1[addr])           ;write data to ram
 01A                             ;update current disp position
 01A  07F02                      XOR sF[switch_a_b], 02               ;toggle between 00, 02
 01B              proc_btn_done: 
 01B  25000                      RETURN 
 01C                             ;=========================================================
 01C                             ;routine:  final_bcd_result
 01C                             ;  function: returns  multiplication result in bcd
 01C                             ;=========================================================
 01C           final_bcd_result: 
 01C  01019                      LOAD s0[data], 19[prod_lsb]
 01D  2D000                      OUTPUT s0[data], 00[result_lsb_port]
 01E  01020                      LOAD s0[data], 20[prod_msb]
 01F  2D001                      OUTPUT s0[data], 01[result_msb_port]
 020  25000                      RETURN 
 021                             ;=========================================================
 021                             ;routine: multab
 021                             ;  function: get  a*b bin result
 021                             ;=========================================================
 021                     multab: 
 021  0B317                      FETCH s3, 17[a_bin]
 022  0B418                      FETCH s4, 18[b_bin]
 023  2008F                      CALL 08F[mult_hard]
 024  2F519                      STORE s5, 19[prod_lsb]               ;
 025  2F620                      STORE s6, 20[prod_msb]
 026  25000                      RETURN 
 027                             ;=========================================================
 027                             ;routine: convert_bin_to_bcd
 027                             ;  function: check if it is a bcd number
 027                             ;  input register:
 027                             ;  output register:
 027                             ;=========================================================
 027         convert_bin_to_bcd: 
 027  0B319                      FETCH s3, 19[prod_lsb]               ;
 028  0B420                      FETCH s4, 20[prod_msb]
 029  01210                      LOAD s2[i], 10                       ;
 02A  03500                      AND s5, 00                           ;BCD0,BCD1
 02B  03600                      AND s6, 00                           ;BC1,BCD2
 02C                   alg_loop: 
 02C                             ;CHECAR SE ALGUM DIGITO BCD Ã‰ MAIOR QUE 4
 02C  00750                      LOAD s7, s5
 02D  0370F                      AND s7, 0F                           ; BCD0
 02E  01E05                      LOAD sE, 05
 02F  1CE70                      COMPARE sE, s7                       ; bcd0 >4?
 030  3A032                      JUMP C, 032[BCD1_label]              ; nop
 031  11703                      ADD s7, 03                           ;yes +3
 032                 BCD1_label: 
 032  00850                      LOAD s8, s5
 033  038F0                      AND s8, F0                           ;BCD1
 034  01E50                      LOAD sE, 50
 035  1CE80                      COMPARE sE, s8                       ; bcd1 > 4?
 036  3A038                      JUMP C, 038[BCD2_label]              ; nop
 037  11830                      ADD s8, 30                           ; yes +3
 038                 BCD2_label: 
 038  00960                      LOAD s9, s6
 039  0390F                      AND s9, 0F                           ; BCD2
 03A  01E05                      LOAD sE, 05
 03B  1CE90                      COMPARE sE, s9                       ; bcd2 >4?
 03C  3A03E                      JUMP C, 03E[BCD3_label]              ; nop
 03D  11903                      ADD s9, 03                           ; yes
 03E                 BCD3_label: 
 03E  00A60                      LOAD sA, s6
 03F  03AF0                      AND sA, F0                           ; BCD3
 040  01E50                      LOAD sE, 50
 041  1CEA0                      COMPARE sE, sA                       ; BCD3 >4?
 042  3A044                      JUMP C, 044[shift_pronto]            ; nop
 043  11A30                      ADD sA, 30                           ; yes
 044               shift_pronto: 
 044  03500                      AND s5, 00                           ;
 045  10570                      ADD s5, s7                           ;
 046  10580                      ADD s5, s8                           ;
 047  03600                      AND s6, 00                           ;
 048  10690                      ADD s6, s9
 049  106A0                      ADD s6, sA
 04A  14306                      SL0 s3
 04B  14400                      SLA s4                               ;
 04C  14500                      SLA s5
 04D  14600                      SLA s6
 04E  19201                      SUB s2[i], 01                        ;dec loop index
 04F  3602C                      JUMP NZ, 02C[alg_loop]               ;repeat until i=0
 050  2F515                      STORE s5, 15[p_bcd_result_lsb]
 051  2F616                      STORE s6, 16[p_bcd_result_msb]
 052  25000                      RETURN 
 053                             ;=========================================================
 053                             ;routine: convert_bcd_to_bin
 053                             ;  function: check if it is a bcd number
 053                             ;  input register: data
 053                             ;  output register: data
 053                             ;=========================================================
 053         convert_bcd_to_bin: 
 053  01208                      LOAD s2[i], 08
 054  0B300                      FETCH s3, 00[a_lsb]                  ;
 055  0B402                      FETCH s4, 02[b_lsb]                  ;
 056  03500                      AND s5, 00                           ; a_bin
 057  03600                      AND s6, 00                           ; b_bin
 058               convert_loop: 
 058  1430E                      SR0 s3                               ; shift right a
 059  14508                      SRA s5                               ;
 05A  1440E                      SR0 s4                               ; shift right b
 05B  14608                      SRA s6                               ;
 05C                             ;checar se  bcd > 7 se for subtrair 3
 05C  00730                      LOAD s7, s3
 05D  00830                      LOAD s8, s3
 05E  0370F                      AND s7, 0F                           ; a_bcd0
 05F  038F0                      AND s8, F0                           ; a_bcd1
 060  01E08                      LOAD sE, 08
 061  1CE70                      COMPARE sE, s7                       ; bcd0>7?
 062  3A064                      JUMP C, 064[next_bcd]                ; nop
 063  19703                      SUB s7, 03
 064                   next_bcd: 
 064  01E80                      LOAD sE, 80
 065  1CE80                      COMPARE sE, s8                       ; bcd1>7?
 066  3A068                      JUMP C, 068[b_part]
 067  19830                      SUB s8, 30
 068                     b_part: 
 068  00940                      LOAD s9, s4
 069  00A40                      LOAD sA, s4
 06A  0390F                      AND s9, 0F                           ; b_bcd0
 06B  03AF0                      AND sA, F0                           ; b_bcd1
 06C  01E08                      LOAD sE, 08
 06D  1CE90                      COMPARE sE, s9                       ; bcd0>7?
 06E  3A070                      JUMP C, 070[next_bcd_b]              ; nop
 06F  19703                      SUB s7, 03
 070                 next_bcd_b: 
 070  01E80                      LOAD sE, 80
 071  1CEA0                      COMPARE sE, sA                       ; bcd1>7?
 072  3A074                      JUMP C, 074[sum_bcd]
 073  19830                      SUB s8, 30
 074                    sum_bcd: 
 074  01300                      LOAD s3, 00                          ;
 075  01400                      LOAD s4, 00                          ;
 076  10370                      ADD s3, s7
 077  10380                      ADD s3, s8
 078  10490                      ADD s4, s9
 079  104A0                      ADD s4, sA
 07A  19201                      SUB s2[i], 01                        ;dec loop index
 07B  36058                      JUMP NZ, 058[convert_loop]           ;repeat until i=0
 07C  2F517                      STORE s5, 17[a_bin]
 07D  2F618                      STORE s6, 18[b_bin]
 07E  25000                      RETURN 
 07F                             ;=========================================================
 07F                             ;routine: check_bcd_valid
 07F                             ;  function: check if it is a bcd number
 07F                             ;  input register: data
 07F                             ;  output register: data
 07F                             ;=========================================================
 07F            check_bcd_valid: 
 07F  1D010                      COMPARE s0[data], 10                 ;
 080  3A082                      JUMP C, 082[valid]
 081  22085                      JUMP 085[bcd_error]
 082                      valid: 
 082  01000                      LOAD s0[data], 00
 083  2D004                      OUTPUT s0[data], 04[erro_port]
 084  25000                      RETURN 
 085                  bcd_error: 
 085  010FF                      LOAD s0[data], FF
 086  2D004                      OUTPUT s0[data], 04[erro_port]
 087  25000                      RETURN 
 088                             ;enviar error
 088                             ;=========================================================
 088                             ;routine: get_lower_nibble
 088                             ;  function: get lower 4-bit of data
 088                             ;  input register: data
 088                             ;  output register: data
 088                             ;=========================================================
 088           get_lower_nibble: 
 088  0300F                      AND s0[data], 0F                     ;clear upper nibble
 089  25000                      RETURN 
 08A                             ;=========================================================
 08A                             ;routine: get_lupper_nible
 08A                             ;  function: get upper 4-bit of in_data
 08A                             ;  input register: data
 08A                             ;  output register: data
 08A                             ;=========================================================
 08A           get_upper_nibble: 
 08A  1400E                      SR0 s0[data]                         ;right shift 4 times
 08B  1400E                      SR0 s0[data]
 08C  1400E                      SR0 s0[data]
 08D  1400E                      SR0 s0[data]
 08E  25000                      RETURN 
 08F                             ;=========================================================
 08F                             ;routine: mult_hard
 08F                             ;  function: 8-bit unsigned multiplication using
 08F                             ;            external combinational multilplier;
 08F                             ;  input register:
 08F                             ;     s3: multiplicand
 08F                             ;     s4: multiplier
 08F                             ;  output register:
 08F                             ;     s5: upper byte of product
 08F                             ;     s6: lower byte of product
 08F                             ;  temp register:
 08F                             ;=========================================================
 08F                  mult_hard: 
 08F  2D302                      OUTPUT s3, 02[mult_src0_port]
 090  2D403                      OUTPUT s4, 03[mult_src1_port]
 091  09502                      INPUT s5, 02[mult_prod0_port]        ; lower
 092  09603                      INPUT s6, 03[mult_prod1_port]        ; upper
 093  25000                      RETURN 


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\aluno\Desktop\vga_text\KCPSM6_Release9_30Sept14.zip (Unzipped Files)\mult_rom.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   15'd         
 timestamp_minutes 39'd         
 timestamp_seconds 10'd         
 datestamp_year    23'd         
 datestamp_month   2'd          
 datestamp_day     15'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 a_lsb             00           mult_rom.psm
 b_lsb             02           mult_rom.psm
 aa_lsb            04           mult_rom.psm
 aa_msb            05           mult_rom.psm
 bb_lsb            06           mult_rom.psm
 bb_msb            07           mult_rom.psm
 aabb_lsb          08           mult_rom.psm
 aabb_msb          09           mult_rom.psm
 aabb_cout         0A           mult_rom.psm
 led0              10           mult_rom.psm
 led1              11           mult_rom.psm
 led2              12           mult_rom.psm
 led3              13           mult_rom.psm
 save              14           mult_rom.psm
 p_bcd_result_lsb  15           mult_rom.psm
 p_bcd_result_msb  16           mult_rom.psm
 a_bin             17           mult_rom.psm
 b_bin             18           mult_rom.psm
 prod_lsb          19           mult_rom.psm
 prod_msb          20           mult_rom.psm
 rd_flag_port      00           mult_rom.psm
 sw_port           01           mult_rom.psm
 mult_prod0_port   02           mult_rom.psm
 mult_prod1_port   03           mult_rom.psm
 result_lsb_port   00           mult_rom.psm
 result_msb_port   01           mult_rom.psm
 mult_src0_port    02           mult_rom.psm
 mult_src1_port    03           mult_rom.psm
 erro_port         04           mult_rom.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "15 Feb 2023"  
 timestamp$        "15:39:10"     



List of line labels

   Label                Addr  Source PSM File

   forever              001   mult_rom.psm
   init                 007   mult_rom.psm
   clr_mem_loop         009   mult_rom.psm
   proc_btn             00E   mult_rom.psm
   chk_btns             013   mult_rom.psm
   proc_btn_done        01B   mult_rom.psm
   final_bcd_result     01C   mult_rom.psm
   multab               021   mult_rom.psm
   convert_bin_to_bcd   027   mult_rom.psm
   alg_loop             02C   mult_rom.psm
   BCD1_label           032   mult_rom.psm
   BCD2_label           038   mult_rom.psm
   BCD3_label           03E   mult_rom.psm
   shift_pronto         044   mult_rom.psm
   convert_bcd_to_bin   053   mult_rom.psm
   convert_loop         058   mult_rom.psm
   next_bcd             064   mult_rom.psm
   b_part               068   mult_rom.psm
   next_bcd_b           070   mult_rom.psm
   sum_bcd              074   mult_rom.psm
   check_bcd_valid      07F   mult_rom.psm
   valid                082   mult_rom.psm
   bcd_error            085   mult_rom.psm
 * get_lower_nibble     088   mult_rom.psm
 * get_upper_nibble     08A   mult_rom.psm
   mult_hard            08F   mult_rom.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             28
 STAR              -

 AND              15
 OR                -
 XOR               1

 ADD              13
 ADDCY             -
 SUB               7
 SUBCY             -

 TEST              2
 TESTCY            -
 COMPARE           9
 COMPARECY         -

 SL0               1
 SL1               -
 SLX               -
 SLA               3
 RL                -
 SR0               6
 SR1               -
 SRX               -
 SRA               2
 RR                -

 REGBANK           -

 INPUT             4
 OUTPUT            6
 OUTPUTK           -

 STORE             6
 FETCH             6

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             17
 JUMP@             -
 CALL              9
 CALL@             -
 RETURN           11
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
